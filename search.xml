<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML5新增了哪些语义标签]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FHTML5%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AF%AD%E4%B9%89%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[&lt;article&gt; 定义文章 &lt;aside&gt; 定义文章的侧边栏 &lt;figure&gt; 一组媒体对象以及文字 &lt;figcaption&gt; 定义 figure 的标题 &lt;footer&gt;定义页脚 &lt;header&gt;定义页眉 &lt;hgroup&gt;定义对网页标题的组合 &lt;nav&gt;定义导航 &lt;section&gt; 定义文档中的区段 &lt;time&gt;定义日期和时间 &lt;dialog&gt;定义一个对话框 &lt;header&gt;&lt;/header&gt; &lt;footer&gt;&lt;/footer&gt; &lt;nav&gt;&lt;/nav&gt; &lt;section&gt; &lt;section&gt; 页面上的版块 用于划分页面上的不同区域,或者划分文章里不同的节 &lt;article&gt;&lt;/ article &gt; 用来在页面中表示一套结构完整且独立的内容部分，可以用来呈现论坛的一个帖子，杂志或报纸中的一篇文章，一篇博客，用户提交的评论内容等。 &lt;figure&gt; 标签规定独立的流内容（图像、图表、照片、代码等等）。 &lt;figcaption&gt; figure的子元素 用于对figure的内容 进行说明 &lt;time&gt;&lt;/time&gt; &lt;datalist&gt;&lt;/datalist&gt;选项列表。与 input 元素配合使用，来定义 input 可能的值。 &lt;mark&gt;&lt;/mark&gt; 需要标记的词或句子 &lt;details&gt;&lt;/details&gt;用于描述文档或文档某个部分的细节 &lt;summary&gt;&lt;/summary&gt; details 元素的标题 该元素用于摘录引用等 应该与页面的主要内容区分开的其他内容 Open 属性默认展开 状态交互元素 progress元素 ：标签定义运行中的进度（进程） &lt;progress value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt; meter元素 ：标签定义度量衡。仅用于已知最大和最小值的度量。 &lt;meter value=&quot;70&quot; max=&quot;100&quot; min=&quot;0&quot;&gt;&lt;/meter&gt; Forms email : 电子邮箱文本框，跟普通的没什么区别,当输入不是邮箱的时候，验证通不过.移动端的键盘会有变化 tel : 电话号码,移动端的键盘 url : 网页的URL search : 搜索引擎 range : 特定范围内的数值选择器 min、max、step( 步数 )、value 用JS来显示当前数值 新的表单特性和函数 placeholder : 输入框提示信息 例子 : 密码框提示 autocomplete : 是否保存用户输入值默认为on，关闭提示选择off autofocus : 指定表单获取输入焦点 list和datalist : 为输入框构造一个选择列表 list值为datalist标签的id required : 此项必填，不能为空带有必填字段的表单 Pattern : 正则验证 pattern=&quot;\d{1,5}“ formaction 在submit里定义提交地址]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>语义化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习笔记（二）]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[HTML语义化 1、什么是HTML语义化？ 基本上都是围绕着几个主要的标签，像标题（H1~H6）、列表（li）、强调（strong em）等等 根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 2、为什么要语义化？ 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看； 用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 3、写HTML代码时应注意什么？ 尽可能少的使用无语义的标签div和span； 在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 不要使用纯样式标签，如：b、font、u等，改用css设置。 需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 表单域要用fieldset标签包起来，并用legend标签说明表单的用途； 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。 4、HTML5新增了哪些语义标签，详述之。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>HTML语义化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习笔记（一）]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[什么是模块化？ • 模块化就是为了减少系统耦合度，提高高内聚，减少资源循环依赖，增强系统框架设计。 • 让开发者便于维护,同时也让逻辑相同的部分可复用 • 模块化开发：针对js、css，以功能或业务为单元组织代码。js方面解决独立作用域、依赖管理、api暴露、按需加载与执行、安全合并等问题，css方面解决依赖管理、组件内部样式管理等问题。 任何事物都有一个过程，那么模块化的过程通俗点讲就是：模块化的过程就是： • 1、拆分将整个系统按功能,格式,加载顺序,继承关系分割为一个一个单独的部分.注意:拆分的粒度问题,可复用问题,效率问题.如何这些问题处理的不好，就有可能出现不想要的后果。 将功能或特征相似的部分组合在一起,组成一个资源块.将每个资源块按找需求,功能场景以及目录约束放到固定的地方以供调用.模块的历程模块化的发展也是从草根一步一步走过来的。 从最开始到现在成熟方案： namespace sass,less AMD&amp;CMD html模版 grunt,gulp,webpack FIS,YUI,KISSY]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 基本操作]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fgit-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[先创建一个版本库 新建一个文件夹 初始化本地仓库 然后用$ git init初始化一个Git仓库，使用git init命令。 添加（修改）文件到Git仓库 分两步： 第一步，使用命令git add 文件名，注意，可反复多次使用，添加多个文件。 如果更改过多或者不确定自己改了那几个文件可以使用命令git add .提交所有更改过的文件； 第二步，使用命令git commit -m “这里写类似于备注说明一下更新的了什么”，完成。 $ git add readme.txt $ git commit -m &quot;append GPL&quot; [master 3628164] app end GPL 1 file changed, 1 insertion(+), 1 deletion(-) -m后面跟着对这个文件修改的描述 版本回退 使用git log命令查看历史 $ git log commit 3628164fb26d48395383f8f31179f24e0882e1e0 Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Tue Aug 20 15:11:49 2013 +0800 append GPL commit ea34578d5496d7dd233c827ed32a8cd576c5ee85 Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Tue Aug 20 14:53:12 2013 +0800 add distributed commit cb926e7ea50ad11b8f9e909c05226233bf755030 Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Mon Aug 19 17:51:55 2013 +0800 wrote a readme file git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数： $ git log --pretty=oneline3628164fb26d48395383f8f31179f24e0882e1e0 append GPL ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file 这一大串数字是comment id在Git中，用HEAD表示当前版本，也就是最新的提交，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 把版本返回到上一个版本使用 git reset $ git reset --hard HEAD^ HEAD is now at ea34578 add distributed 如果想要返回没有后退的版本 使用 $ git reset --hard 3628164 HEAD is now at 3628164 append GPL 3628164是版本号 查看自己使用过的命令 Git提供了一个命令git reflog来记录自己使用过的命令 $ git reflog ea34578 HEAD@{0}: reset: moving to HEAD^ 3628164 HEAD@{1}: commit: append GPLea34578 HEAD@{2}: commit: add distribut edcb926e7 HEAD@{3}: commit (initial): wrote a readme file 工作区和暂存区 工作区（Working Directory）就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：版本库（Repository） 这里写图片描述 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 我们把文件往Git版本库里添加的时候，是分两步执行的：第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 丢弃工作区更改： git checkout – file可以丢弃工作区的修改： $ git checkout -- readme.txt 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。 删除文件 一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： $ git rm test.txt rm &apos;test.txt&apos; $ git commit -m &quot;remove test.txt&quot; [master d17efd8] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 现在，文件就从版本库中被删除了。另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： $ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 远程仓库 GitHub远程仓库创建注册GitHub账号。由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 点“Add Key”，你就应该看到已经添加的Key： GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库： 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 使github远程仓库和本地git仓库关联 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：$ git remote add origin git@github.com:xxxx/learngit.git上面的michaelliao替换成你自己的GitHub账户名，添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。本地库的所有内容推送到远程库下一步，就可以把本地库的所有内容推送到远程库上： $ git push -u origin master Counting objects: 19, done. Delta compression using up to 4 threads. Compressing objects: 100% (19/19), done. Writing objects: 100% (19/19), 13.73 KiB, done. Total 23 (delta 6), reused 0 (delta 0) To git@github.com:michaelliao/learngit.git * [new branch] master -&gt; master Branch master set up to track remote branch master from origin. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： $ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ SSH警告 当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established. RSA key fingerprint is xx.xx.xx.xx.xx. Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。要关联一个远程库，使用命令 git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容；此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步. 从远程库克隆 那么最好的方式是先创建远程库，然后，从远程库克隆。首先，登陆GitHub，创建一个新的仓库，名字叫gitskills： 我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件： 现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： $ git clone git@github.com:xxxx/gitskills.git Cloning into &apos;gitskills&apos;... remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0) Receiving objects: 100% (3/3), done. $ cd gitskills $ lsREADME.md 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。你也许还注意到，GitHub给出的地址不止一个，还可以用 https://github.com/michaelliao/gitskills.git 这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 分支管理 分支 就是好比你自己在一根树杈上面 你自己怎么弄别人看不到 可以每天提交 那样也不怕代码突然没有了 当全部工作做完后可以合并到以前的分支上面创建和切换分支首先，我们创建dev分支，然后切换到dev分支： $ git checkout -b devSwitched to a new branch &apos;dev&apos; git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： $ git branch dev$ git checkout devSwitched to branch &apos;dev&apos; 然后，用git branch命令查看当前分支： $ git branch * dev master git branch命令会列出所有分支，当前分支前面会标一个*号。然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：Creating a new branch is quick.然后提交： $ git add readme.txt $ git commit -m &quot;branch test&quot; [dev fec145a] branch test 1 file changed, 1 insertion(+) 现在，dev分支的工作完成，我们就可以切换回master分支： $ git checkout masterSwitched to branch &apos;master&apos; 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： 现在，我们把dev分支的工作成果合并到master分支上： $ git merge devUpdating d17efd8..fec145aFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。合并完成后，就可以放心地删除dev分支了： $ git branch -d devDeleted branch dev (was fec145a). 删除后，查看branch，就只剩下master分支了： $ git branch * master 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。Git鼓励大量使用分支：查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 解决冲突 简单来说就是 在你这个分支修改的同时 主分支也修改了 那当他们合并的时候就会发生冲突 如果在一个分支开发着呢 需要开发别的任务 可以先把这个任务保存 $ git stash Saved working directory and index state WIP on dev: 6224937 add mergeHEAD is now at 6224937 add merge 等把别的开发完后 想再继续开发自己这个分支 用git stash list命令看看： $ git stash list stash@{0}: WIP on dev: 6224937 add merge 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了： $ git stash pop On branch dev# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## new file: hello.py## Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)## modified: readme.txt#Dropped refs/stash@{0} (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40) 再用git stash list查看，就看不到任何stash内容了： $ git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： $ git stash apply stash@{0}]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 置顶篇]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fhexo-%E7%BD%AE%E9%A1%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[修改Hexo文件夹下的node_modules/hexo-generator-index/lib/generator.js，在生成文章之前进行文章top值排序。 把下面的内容代替generator.js里的内容 &apos;use strict&apos;; var pagination = require(&apos;hexo-pagination&apos;); module.exports = function(locals) { var config = this.config; var posts = locals.posts.sort(config.index_generator.order_by); posts.data = posts.data.sort(function(a, b) { if(a.top &amp;&amp; b.top) { if(a.top == b.top) return b.date - a.date; else return b.top - a.top; } else if(a.top &amp;&amp; !b.top) { return -1; } else if(!a.top &amp;&amp; b.top) { return 1; } else return b.date - a.date; }); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, { perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: { __index: true } }); }; 修改完成后，只需要在front-matter中设置需要置顶文章的top值，将会根据top值大小来选择置顶顺序top值越大越靠前。需要注意的是，这个文件不是主题的一部分，也不是Git管理的，备份的时候比较容易忽略。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 进阶篇]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fhexo%20%E8%BF%9B%E9%98%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[远程部署 远程部署指的是，博客在我们本地生成好了以后部署到远程仓库去，如果远程仓库支持pages服务的话，那就可以通过这样的方法发布和更新博客。 要使用远程部署需要先安装hexo-deployer-git，注意，这是适用于git类型仓库的方法，其他仓库的方法在文章结尾提供的官网连接中有说明。 运行命令： npm install hexo-deployer-git --save 安装好hexo-deployer-git后，修改博客目录配置文件中的deploy字段： deploy: type: git repo: git仓库项目地址 branch: 分支 message: 自定义提交说明，这个字段可以没有 如果git仓库是ssh，则需要生成.ssh，这是git的操作，不做详述。 有关于博客主题的更换，以及详细配置等 参见官网 https://hexo.io/zh-cn/docs/]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 报错篇]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fhexo%20%E6%8A%A5%E9%94%99%E7%AF%87%2F</url>
    <content type="text"><![CDATA[hexo报错错误 error:推送一些引用到 &#39;git@github.com:xxxx.github.io.git’ 失败 FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html Error:Warning: Permanently added the RSA host key for IP address &apos;xxxx to the list of known hosts. remote:error: GH007: Your push would publish a private email address. remote:You can make your email public or disable this protection by visiting: remote:http://github.com/settings/emails To github.com:xxxx.io.git ! [remote rejected] HEAD -&gt; master (push declined due to email privacy restrictions) 更新文件上传都没问题，但是hexo d推送就会出现这样的报错，不要着急，如果确定自己之前可以推送到github，并且确定自己配置没问题了，可以试着hexo clean清除一下缓存，接着hexo g然后hexo d就可以了！]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 初体验]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fhexo%20%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[之前搭建的一个blog已经凉凉。源文件没有备份，更换电脑导致网站源文件丢失。 hexo是什么？简单的说，就是一个静态博客的生成工具，我这个博客就是就是基于hexo生成的。文章结尾的官网链接中也有介绍。昨天才把这个博客用hexo折腾出来，所以想记录下来折腾的过程，留着以后备用。这里只说如何在windows下成功安装hexo并运行起来，关于主题以及配置不做记录。 安装node.js 因为hexo是基于node.js的，所以node.js是必须要装的，安装也特别简单，去 官网 下载适合自己windows的版本。安装过程一直下一步就行了，什么也不用选，在网上查资料的时候，看到有说要在Custom Setup这一步记得选Add to PATH，但我在安装的时候这个选项是默认选好的，不用动它，也许是版本的原因，建议在安装时留意一下，毕竟自己配置环境变量还是有点麻烦。 安装好以后，打开CMD命令窗口，输入 npm -v ，如果出现版本号，那说明安装成功了并且环境变量也配置好了，如果是未知命令那就要配置一下环境变量。 安装hexo 这一步我是用git bash来安装的，如果安装了git，那么就可以用git bash，如果没有装，那就用CMD窗口，效果是一样一样的，命令都是一样的。 安装hexo的命令： npm install -g hexo-cli 这一步安装的比较慢，可能跟网络环境有关，我在用git bash安装的时候半天没反应，然后用CMD安装成功了。输入 hexo -v 出现一系列的版本号就是安装成功啦，就像下面这样： $ hexo -v hexo: 3.4.2 hexo-cli: 1.0.4 os: Windows_NT 6.1.7601 win32 x64 http_parser: 2.7.0 node: 8.9.1 v8: 6.1.534.47 uv: 1.15.0 zlib: 1.2.11 ares: 1.10.1-DEV modules: 57 nghttp2: 1.25.0 openssl: 1.0.2m icu: 59.1 unicode: 9.0 cldr: 31.0.1 tz: 2017b 从现在开始，我们就可以用hexo来生成一个博客了。首先新建一个文件夹，位置随意，然后 cd 到这个文件夹下，运行命令： hexo init hexo会将这个文件夹初始化成一个博客专用文件夹，生成过程稍微要点时间，耐心等待。初始化完成后，会有一个默认主题以及一个hello-word的默认文章。所以我们可以先生成博客来看一下效果，运行命令： hexo generate //可以简写成 hexo g 然后hexo会开始生成博客，生成结束后，会多出一个public的文件夹，这个文件夹就是hexo生成的一个完整的静态网站，也就是我们的博客。网站生成好了，我们要浏览它，所以要开启一下服务器，运行命令： hexo server //可以简写成 hexo s 然后打开浏览器，输入localhost:4000 就可以浏览我们的博客了。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
